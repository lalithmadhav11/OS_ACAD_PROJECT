log_event :
// WHY ?
this is used to trace the synchronistaion process

// PARAMS EXPLAINIG :
role->student or faqculty
why const ? to make sure string doesnt get modified inside the function.
msg -> it tell ys what is being done to role ex : needs help, sits on chair.
id -> for student its form 0 till max_st8udents-1 ; -1 means its faculty.

// LOGIC :
time_t ->a datatype for stoirng time 
       -> it will store time in seconds since Jan 1 1970
time(NULL) -> return the current system time

struct tm *t=localtime(&now):
    -> converts raw time into a human readable time 
    -> struct tm has tm_hours,tm_min,tm_sec
    -> localtime(&now)-> now means current time it will be converted to local timezone FormData.

simulate_work :
// WHY?
it stimualtes delay when -> student doing programming needs help
                         -> faculty helping student
// LOGIC :
random becasue :
        students won’t all ask for help at the same time, and faculty helps for random durations.
        just like a real operating system’s scheduling. 

print_queue :

// WHY ?
to display current waiting students.


faculty_thread :

// ARGS AND  DEF :
Function returns a generic pointer, because that’s the standard type for all pthread functions.
Threads in C must have this signature: void* function(void* arg).

// LOGIC:

why while(1) ?
    Keeps the faculty continuously available — sleeping, waking, helping — until the program is terminated.

sem_wait(&facuulty_sem)?
    sem_wait(x)-> decrements semaphore x 
    if val of facuulty_sem is 0 the thread is blocked(Sleeps).
    if a student calls sem_post(&faculty_Sem) the thread is unblocked and continues.C
    Implements the “sleeping faculty” logic —
    faculty stays asleep until a student wakes them up using a semaphore signal.

pthread_mutex_lock(&chair_mutex):
// why ? 
        to prevent race condition.
// logic 
    locks the chair_mtex in exclusive lock.
    it ensures only on ethread (faculty or stu) to modify or read the shared var such as : waiting_stu,chairs[],next_help

if(waiting_stu==0) // why we are checking? -> of no stu is there facylty should go to sellep
    pthread_mutex_unlock(&chair_mutex)
        relaeses the lock before going to sleep.C
        // why ? -> to prevent deadlock.
        if not there other threads like students cant access the quueue.

int sid=chairs[next_help]; // select next student to help.
next_help=(next_help+1)%MAX_CHAIRS; // moves ptr forward.
waiting_Students--; // since faculty already helped one student we decrement count.

     